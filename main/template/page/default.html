{% extends 'home.html' %}

{% block headscript %}
<script>

    function newLineblock(obj, textAfterCursor) {
        var newLineblock = document.createElement('div');
        newLineblock.setAttribute('class', 'lineblock');
        newLineblock.setAttribute('style', 'width: 100%; max-width: 700px; margin-top: 1px; margin-bottom: 1px; position: relative;');
        newLineblock.innerHTML = '<div style="display: flex; align-items: flex-start; width: 100%; padding-left: 2px; fill: inherit;"></div><div style="flex: 1 1 0px; min-width: 1px; display: flex; flex-direction: column;"><div style="display: flex"><div class="textnode" spellcheck="true" placeholder="텍스트를 입력하세요." data-content-editable-leaf="true" contenteditable="true" style="max-width: 100%; width: 100%; white-space: pre-wrap; word-break: break-word; caret-color: rgb(55, 53, 47); padding: 3px 2px; text-align: left;"></div></div></div>';
        obj.parentNode.insertBefore(newLineblock, obj.nextElementSibling);
        const textNode = newLineblock.children[1].children[0].children[0];
        const textlist = textAfterCursor.split('\n');
        if (textlist.length > 1){
            for(let i = 0; i < textlist.length;i++){
                textNode.appendChild(document.createTextNode(textlist[i]));
                if(i !== textlist.length - 1){
                    textNode.appendChild(document.createTextNode('\n'));
                }
            }
        }else if (textlist.length == 1 && textlist[0].length > 0){
            textNode.appendChild(document.createTextNode(textlist[0]));
        }
        textNode.focus();
        return newLineblock;
    }

    function enterToNewLineblock(element, position){
        const textNodes = Array.from(getTextNodes(element));
        const coordinates = getCursorCoordinates(element);
        const newBlock = newLineblock(element.parentNode.parentNode.parentNode, "");
        
        if(element.firstChild == undefined || element.firstChild.textContent == ""){
            return;
        }

        const selection = window.getSelection();
        const range = document.createRange();
        range.selectNodeContents(element);
        range.collapse(false);

        selection.removeAllRanges();
        
        const e = newBlock.children[1].children[0].children[0];
        for(let i = 0; i < textNodes.length; i++){
            if(coordinates.lineNum == i/2+1){
                console.log(i/2+1, coordinates.lineNum);
                range.setStart(textNodes[i], position);
                console.log(range);
                const cursorPosition = range.startOffset;
                console.log(cursorPosition);
                const textAfterCursor = textNodes[i].textContent.substring(cursorPosition);
                console.log(textAfterCursor)
                textNodes[i].textContent = textNodes[i].textContent.slice(0, cursorPosition);
                e.appendChild(document.createTextNode(textAfterCursor));
            }
            else if(coordinates.lineNum < i/2+1){
                console.log(i/2+1, coordinates.lineNum);
                e.appendChild(textNodes[i])
            }
        }
    }

    function deleteLineblock(obj, textAfterCursor) {
        var previousLineblock = obj.previousElementSibling;
        obj.remove();
        const textNode = previousLineblock.children[1].children[0].children[0];
        textNode.focus();
        addText(textNode, textAfterCursor);
    }

    function addText(element, text, position) {
        // Ctrl+V등 텍스트 외부적으로 추가시
        const textList = text.split('\n');
        const textNodes = getTextNodes(element);
        if (textNodes.length > 0){
            for(let i = 0; i < textNodes.length; i++){
            if(coordinates.lineNum == i/2+1){
                console.log(i/2+1, coordinates.lineNum);
                range.setStart(textNodes[i], position);
                console.log(range);
                const cursorPosition = range.startOffset;
                console.log(cursorPosition);
                const textAfterCursor = textNodes[i].textContent.substring(cursorPosition);
                console.log(textAfterCursor)
                textNodes[i].textContent = textNodes[i].textContent.slice(0, cursorPosition);
                e.appendChild(document.createTextNode(textAfterCursor));
            }
            else if(coordinates.lineNum < i/2+1){
                console.log(i/2+1, coordinates.lineNum);
                e.appendChild(textNodes[i])
            }
        }
        }
        
        }
        

    function moveCursorToPositionTop(element, position) {
        
        const range = document.createRange();
        const selection = window.getSelection();
        const textNodes = Array.from(getTextNodes(element));
        if(textNodes.length == 0){
            element.focus();
            return;
        }
        const firstText = textNodes[0];
        if (position > firstText.length) {
            position = firstText.length;
        }
        range.selectNodeContents(element);
        range.collapse(false);

        selection.removeAllRanges();
        range.setStart(firstText, position);
        range.collapse(true);
        selection.addRange(range);
    }
    function moveCursorToEnd(element) {
        const textNodes = getTextNodes(element);
        const text = textNodes[0];
        if(textNodes[0] == undefined){
            moveCursorToPositionTop(element, 0);
        }else{
            const position = text.length;
            moveCursorToPositionTop(element, position);
        }
        
    }
    function moveCursorToPositionBottom(element, position) {
        const range = document.createRange();
        const selection = window.getSelection();
        const textNodes = Array.from(getTextNodes(element));
        if(textNodes.length == 0){
            element.focus();
            return;
        }
        const lastText = textNodes[textNodes.length - 1];
        if (position > lastText.length) {
            position = lastText.length;
        }
        range.selectNodeContents(element);
        range.collapse(false);

        selection.removeAllRanges();
        range.setStart(lastText, position);
        console.log(range);
        range.collapse(true);
        selection.addRange(range);

    }

    function getCursorCoordinates(element) {
        let lineNum = 1, lastLine = 1;
        const selection = window.getSelection();
        const cursorRange = selection.getRangeAt(0);
        const cursorRect = cursorRange.getBoundingClientRect();
        
        const textNodes = getTextNodes(element);
        if (textNodes[0] == undefined){
            return { lineNum, lastLine };
        }
        if (textNodes[0].textContent == ""){
            return { lineNum, lastLine };
        }
        const rects = textNodes.map(node => {
            const range = document.createRange();
            range.selectNodeContents(node);
            return range.getBoundingClientRect();
        });
        const firstLineY = rects[0].top;
        const lastLineY = rects[(rects.length-1)].bottom;
        const lineheight = rects[0].height;
        
        const y = cursorRect.y;
        lineNum = Math.floor((y - firstLineY) / lineheight) + 1;
        lastLine = Math.floor((lastLineY - firstLineY) / lineheight);
        return { lineNum, lastLine };
    }

    function getTextNodes(element) {
        const textNodes = []; 
        const treeWalker = document.createTreeWalker(
            element,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );

        let node;
        while (node = treeWalker.nextNode()) {
            textNodes.push(node);
        }

        return textNodes;
    }

    function moveCursorToTextNodeStart(textNode) {
        const range = document.createRange();
        const selection = window.getSelection();

        range.setStart(textNode, 0);
        range.collapse(true);

        selection.removeAllRanges();
        selection.addRange(range);

        const parentElement = textNode.parentElement;
        if (parentElement) {
            parentElement.focus();
        }
    }

</script>
{% endblock headscript %}

{% block page %}
<style>
    [contenteditable="true"]:focus:empty:before {
        content: attr(placeholder);
        color: #666
    }
    
</style>
<div class="layout" style="position: relative; padding-bottom: 300px; cursor: text;">
    <div class="layout-content"
        style="display: flex; flex-direction: column; align-items: center; width: 100%; position: relative;">
        <div class="headerblock"
            style="display: flex; flex-direction: column; align-items: center; width: 100%; position: relative; height: 165px;">
            <div class="coverblock" style="max-width: 700px; width: 100%; position: relative; height: 110px;">

            </div>
            <div class="htextblock"
                style="max-width: 700px; width: 100%; height: 55px; position: relative; font-size: 40px; font-weight: bolder;"
                contenteditable="true">
                제목 입력
            </div>
        </div>

    </div>
    <div class="layout-content" id="textarea"
        style="display: flex; flex-direction: column; align-items: center; width: 100%; position: relative;">

        <div class="lineblock"
            style="width: 100%; max-width: 700px; margin-top: 1px; margin-bottom: 1px; position: relative;">
            <div style="
                      display: flex;
                      align-items: flex-start;
                      width: 100%;
                      padding-left: 2px;
                      fill: inherit;
                    ">
            </div>
            <div style="
                        flex: 1 1 0px;
                        min-width: 1px;
                        display: flex;
                        flex-direction: column;
                      ">
                <div style="display: flex">
                    <div class="textnode" spellcheck="true" placeholder="텍스트를 입력하세요." data-content-editable-leaf="true"
                        contenteditable="true" style="
                            max-width: 100%;
                            width: 100%;
                            white-space: pre-wrap;
                            word-break: break-word;
                            caret-color: rgb(55, 53, 47);
                            padding: 3px 2px;
                            text-align: left;
                          "></div>
                    <!-- <div style="position: relative; left: 0px"></div> -->
                </div>
            </div>
        </div>
    </div>
</div>
</div>
{% endblock page %}
{% block bodyscript %}
<script>
    document.addEventListener('DOMContentLoaded', (event) => {
        const textarea = document.getElementById('textarea');

        textarea.addEventListener('keydown', function (event) {
            

            const activeElement = document.activeElement;
            const textNode = event.target;
            if (activeElement === textNode) {
                if (event.key === 'Enter') {
                    if (event.shiftKey) {
                        // Shift+Enter 입력 시 줄바꿈 처리 (기본 동작)
                    } else {
                        event.preventDefault(); // 기본 Enter 동작을 막음
                        const selection = window.getSelection();
                        const range = selection.getRangeAt(0);
                        const cursorPosition = range.endOffset;
                        enterToNewLineblock(textNode, cursorPosition);
                        
                    }
                }
                if (event.key === 'Backspace') {
                    const selection = window.getSelection();
                    const range = selection.getRangeAt(0);
                    const cursorPosition = range.endOffset;
                    const textBeforeCursor = textNode.textContent.substring(0, cursorPosition);
                    if (textBeforeCursor === '') {
                        event.preventDefault(); // 기본 Backspace 동작을 막음
                        curLineblock = textNode.parentNode.parentNode.parentNode;
                        deleteLineblock(curLineblock, textNode.textContent);
                    }
                }
                else if (event.key === 'ArrowLeft') {
                    const selection = window.getSelection();
                    const range = selection.getRangeAt(0);
                    if (range.startOffset === 0 && range.endOffset === 0) {
                        const curLineblock = textNode.parentNode.parentNode.parentNode;
                        const previousLineblock = curLineblock.previousElementSibling;
                        const previousTextNode = previousLineblock.children[1].children[0].children[0];
                        if (previousTextNode && previousLineblock.classList.contains('lineblock')) {
                            event.preventDefault();
                            moveCursorToEnd(previousTextNode);
                        }
                    }
                }
                else if (event.key === 'ArrowRight') {
                    const selection = window.getSelection();
                    const range = selection.getRangeAt(0);
                    const curLineblock = textNode.parentNode.parentNode.parentNode;
                    if (range.startOffset === textNode.textContent.length && range.endOffset === textNode.textContent.length) {
                        const nextLineblock = curLineblock.nextElementSibling;
                        const nextTextNode = nextLineblock.children[1].children[0].children[0];
                        if (nextTextNode && nextLineblock.classList.contains('lineblock')) {
                            event.preventDefault();
                            moveCursorToPositionTop(nextTextNode, 0);
                        }
                    }
                }
                else if (event.key === 'ArrowDown') {
                    const selection = window.getSelection();
                    const range = selection.getRangeAt(0);
                    const curLineblock = textNode.parentNode.parentNode.parentNode;

                    const nextLineblock = curLineblock.nextElementSibling;
                    const nextTextNode = nextLineblock.children[1].children[0].children[0];
                    if (nextTextNode && nextLineblock.classList.contains('lineblock')) {
                        const coordinates = getCursorCoordinates(textNode);
                        console.log("coordinates : ", coordinates);
                        if(coordinates.lineNum === coordinates.lastLine || coordinates.lineNum === NaN){
                            event.preventDefault();
                            console.log("down")
                            const selection = window.getSelection();
                            const range = selection.getRangeAt(0);
                            const cursorPosition = range.endOffset;
                            moveCursorToPositionTop(nextTextNode, cursorPosition);
                        }

                    }
                }
                else if (event.key === 'ArrowUp') {
                    const selection = window.getSelection();
                    const range = selection.getRangeAt(0);
                    const curLineblock = textNode.parentNode.parentNode.parentNode;
                    const previousLineblock = curLineblock.previousElementSibling;
                    const previousTextNode = previousLineblock.children[1].children[0].children[0];
                    if (previousTextNode && previousLineblock.classList.contains('lineblock')) {
                        const coordinates = getCursorCoordinates(textNode);
                        console.log("coordinates : ", coordinates);
                        if(coordinates.lineNum === 1 || coordinates.lineNum === NaN){
                        event.preventDefault();
                        console.log("up")
                        const selection = window.getSelection();
                        const range = selection.getRangeAt(0);
                        const cursorPosition = range.endOffset;
                        moveCursorToPositionBottom(previousTextNode, cursorPosition);
                        }
                    }
                }
            }
        });
    });
</script>
{% endblock bodyscript %}

    