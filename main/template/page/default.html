{% extends 'home.html' %}

{% block headscript %}
<script>

    function newLineblock(block, textAfterCursor) {
        var newBlock = document.createElement('div');
        newBlock.setAttribute('class', 'lineblock');
        newBlock.setAttribute('style', 'width: 100%; max-width: 700px; margin-top: 1px; margin-bottom: 1px; position: relative;');
        newBlock.innerHTML = '<div style="display: flex; align-items: flex-start; width: 100%; padding-left: 2px; fill: inherit;"></div><div style="flex: 1 1 0px; min-width: 1px; display: flex; flex-direction: column;"><div style="display: flex"><div class="textinput" spellcheck="true" placeholder="텍스트를 입력하세요." data-content-editable-leaf="true" contenteditable="true" style="max-width: 100%; width: 100%; white-space: pre-wrap; word-break: break-word; caret-color: rgb(55, 53, 47); padding: 3px 2px; text-align: left;"></div></div></div>';
        block.parentNode.insertBefore(newBlock, block.nextElementSibling);
        const textinput = newBlock.children[1].children[0].children[0];
        if (textAfterCursor === "") {
            return newBlock;
        }
        const textlist = textAfterCursor.split('\n');
        if (textlist.length > 1) {
            for (let i = 0; i < textlist.length; i++) {
                textinput.appendChild(document.createTextNode(textlist[i]));
                if (i !== textlist.length - 1) {
                    textinput.appendChild(document.createTextNode('\n'));
                }
            }
        } else if (textlist.length == 1) {
            textinput.appendChild(document.createTextNode(textlist[0]));
        }
        return newBlock;
    }

    function enterToNewLineblock(textinput, position) {
        const textNodes = getTextNodes(textinput);
        const coordinates = getCursorCoordinates(textinput);
        console.log("coordinates:",coordinates);
        const newBlock = newLineblock(textinput.parentNode.parentNode.parentNode, "");

        if (textinput.firstChild == undefined || textinput.firstChild.textContent == "") {
            console.log("textinput.firstChild:",textinput.firstChild);
            newBlock.children[1].children[0].children[0].focus();
            return;
        }

        const selection = window.getSelection();
        const range = document.createRange();

        const newTextinput = newBlock.children[1].children[0].children[0];
        for (let i = 0; i < textNodes.length; i++) {
            if (coordinates.lineNum == i / 2 + 1) {
                range.setStart(textNodes[i], position);
                const cursorPosition = range.startOffset;
                console.log("cursorPosition:",cursorPosition);
                const textAfterCursor = textNodes[i].textContent.substring(cursorPosition);
                console.log("textAfterCursor:",textAfterCursor);
                textNodes[i].textContent = textNodes[i].textContent.slice(0, cursorPosition);
                if(textAfterCursor.length !== 0){
                    newTextinput.appendChild(document.createTextNode(textAfterCursor));
                }
            }
            else if (coordinates.lineNum < i / 2 + 1) {
                newTextinput.appendChild(textNodes[i])
            }
        }
        newTextinput.focus();
    }

    function deleteLineblock(block, textAfterCursor) {
        var previousLineblock = block.previousElementSibling;
        block.remove();
        const textinput = previousLineblock.children[1].children[0].children[0];
        const textNodes = getTextNodes(textinput);
        moveCursorToPositionBottom(textinput, 1000)

        let togoPosition = 0;
        if(textNodes.length > 0){
            const lastNode = textNodes[textNodes.length-1];
            togoPosition = lastNode.length;
            addText(textinput, textAfterCursor, lastNode.length);

        }else{
            addText(textinput, textAfterCursor, 0);
            togoPosition = 0;
        }
        console.log("togoPosition:",togoPosition);
        moveCursorToPositionBottom(textinput, togoPosition)

    }

    function addText(textinput, text, position) {
        console.log("position:",position);
        let lastTextLength = 1000;
        let addLine = 0;
        if(text.length == 0){
            return addLine, lastTextLength;
        }
        // Ctrl+V등 텍스트 외부적으로 추가시
        const textList = text.split('\n');
        console.log("textList:",textList);
        
        const coordinates = getCursorCoordinates(textinput);
        console.log("coordinates:",coordinates);
        if (textinput.firstChild == undefined) {
            textinput.appendChild(document.createTextNode(''));
        }
        const textNodes = getTextNodes(textinput);
        console.log("textNodes:",textNodes);
        const selection = window.getSelection();
        const range = document.createRange();

        lastTextLength = 0;
        for (let i = 0; i < textNodes.length; i++) {
            if (coordinates.lineNum == i / 2 + 1) {
                range.setStart(textNodes[i], position);
                const cursorPosition = range.startOffset;
                console.log("cursorPosition:",cursorPosition);

                const textAfterCursor = textNodes[i].textContent.substring(cursorPosition);
                textNodes[i].textContent = textNodes[i].textContent.slice(0, cursorPosition);
                if (textList.length == 1) {
                    textNodes[textNodes.length-1].textContent += textList[0]
                    lastTextLength = textList[0].length;
                } else{
                    for (let j = 0; j < textList.length; j++) {
                        if (j == 0) {
                            console.log("textNodes[i]:",textNodes[i]);
                            textNodes[i].textContent += textList[j]
                            console.log("textNodes[i]:",textNodes[i]);
                        } else if (j == textList.length - 1) {
                            if (i == textNodes.length - 1) {
                                textinput.appendChild(document.createTextNode('\n'));
                                textinput.appendChild(document.createTextNode(textList[j]));
                                addLine++;
                            } else {
                                textinput.insertBefore(document.createTextNode('\n'), textNodes[i + 1]);
                                textNodes[i + 1].textContent = textList[j] + textNodes[i + 1].textContent;
                                addLine++;
                            }
                            console.log("막줄:",textList[j]);
                            lastTextLength = textList[j].length;
                            
                        } else {
                            textinput.insertBefore(document.createTextNode('\n'), textNodes[i + 1]);
                            textinput.insertBefore(document.createTextNode(textList[j]), textNodes[i + 1]);
                        }
    
                    }

                }
            }
            else if (coordinates.lineNum < i / 2 + 1) {
                textinput.appendChild(textNodes[i])
            }
        }
        return addLine, lastTextLength;
    }


    function moveCursorToPositionTop(textinput, position) {
        const range = document.createRange();
        const selection = window.getSelection();
        const textNodes = getTextNodes(textinput);
        if (textNodes.length == 0) {
            textinput.focus();
            return;
        }
        const firstText = textNodes[0];
        if (position > firstText.length) {
            position = firstText.length;
        }
        range.selectNodeContents(textinput);
        range.collapse(false);

        selection.removeAllRanges();
        range.setStart(firstText, position);
        range.collapse(true);
        selection.addRange(range);
    }

    function moveCursorToPositionBottom(textinput, position) {
        const range = document.createRange();
        const selection = window.getSelection();
        const textNodes = getTextNodes(textinput);
        if (textNodes.length == 0) {
            textinput.focus();
            return;
        }
        const lastText = textNodes[textNodes.length - 1];
        if (position > lastText.length) {
            position = lastText.length;
        }
        range.selectNodeContents(textinput);
        range.collapse(false);

        selection.removeAllRanges();
        range.setStart(lastText, position);
        range.collapse(true);
        selection.addRange(range);

    }

    function getCursorCoordinates(textinput) {
        let lineNum = 1, lastLine = 1;
        const selection = window.getSelection();
        const cursorRange = selection.getRangeAt(0);
        const cursorRect = cursorRange.getBoundingClientRect();
        console.log("textinput:",textinput);
        console.log("cursorRange:",cursorRange);
        console.log("cursorRect:",cursorRect);
        const textNodes = getTextNodes(textinput);
        if (textNodes[0] == undefined) {
            return { lineNum, lastLine };
        }
        if (textNodes[0].textContent == "") {
            return { lineNum, lastLine };
        }
        const rects = textNodes.map(node => {
            const range = document.createRange();
            range.selectNodeContents(node);
            return range.getBoundingClientRect();
        });
        console.log("rects:",rects);
        const firstLineY = rects[0].top;
        const lastLineY = rects[(rects.length - 1)].bottom;
        const lineheight = rects[0].height;

        const y = cursorRect.y;
        lineNum = Math.floor((y - firstLineY) / lineheight) + 1;
        lastLine = Math.floor((lastLineY - firstLineY) / lineheight);
        return { lineNum, lastLine };
    }

    function getTextNodes(textinput) {
        const textNodes = [];
        const treeWalker = document.createTreeWalker(
            textinput,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );

        let node;
        while (node = treeWalker.nextNode()) {
            textNodes.push(node);
        }

        return Array.from(textNodes);
    }

    function moveCursorToTextNodeStart(textinput) {
        const range = document.createRange();
        const selection = window.getSelection();

        range.setStart(textinput, 0);
        range.collapse(true);

        selection.removeAllRanges();
        selection.addRange(range);

        const parentElement = textinput.parentElement;
        if (parentElement) {
            parentElement.focus();
        }
    }

</script>
{% endblock headscript %}

{% block page %}
<style>
    [contenteditable="true"]:focus:empty:before {
        content: attr(placeholder);
        color: #666
    }
</style>
<div class="layout" style="position: relative; padding-bottom: 300px; cursor: text;">
    <div class="layout-content"
        style="display: flex; flex-direction: column; align-items: center; width: 100%; position: relative;">
        <div class="headerblock"
            style="display: flex; flex-direction: column; align-items: center; width: 100%; position: relative; height: 165px;">
            <div class="coverblock" style="max-width: 700px; width: 100%; position: relative; height: 110px;">

            </div>
            <div class="htextblock"
                style="max-width: 700px; width: 100%; height: 55px; position: relative; font-size: 40px; font-weight: bolder;"
                contenteditable="true">
                제목 입력
            </div>
        </div>

    </div>
    <div class="layout-content" id="textarea"
        style="display: flex; flex-direction: column; align-items: center; width: 100%; position: relative;">

        <div class="lineblock"
            style="width: 100%; max-width: 700px; margin-top: 1px; margin-bottom: 1px; position: relative;">
            <div style="
                      display: flex;
                      align-items: flex-start;
                      width: 100%;
                      padding-left: 2px;
                      fill: inherit;
                    ">
            </div>
            <div style="
                        flex: 1 1 0px;
                        min-width: 1px;
                        display: flex;
                        flex-direction: column;
                      ">
                <div style="display: flex">
                    <div class="textinput" spellcheck="true" placeholder="텍스트를 입력하세요." data-content-editable-leaf="true"
                        contenteditable="true" style="
                            max-width: 100%;
                            width: 100%;
                            white-space: pre-wrap;
                            word-break: break-word;
                            caret-color: rgb(55, 53, 47);
                            padding: 3px 2px;
                            text-align: left;
                          "></div>
                    <!-- <div style="position: relative; left: 0px"></div> -->
                </div>
            </div>
        </div>
    </div>
</div>
</div>
{% endblock page %}
{% block bodyscript %}
<script>
    // document.addEventListener('paste', function (event) {
    //     const activeElement = document.activeElement;
    //     const textinput = event.target;
    //     if (activeElement === textinput) {
    //         event.preventDefault();
    //         const textNodes = getTextNodes(textinput);
    //         const coordinates = getCursorCoordinates(textinput);
    //         const text = (event.originalEvent || event).clipboardData.getData('text/plain');
    //         const selection = window.getSelection();
    //         const range = selection.getRangeAt(0);
    //         const cursorPosition = range.endOffset;
    //         let addLine, lastTextLength = addText(textinput, text, cursorPosition);
    //         console.log(textNodes[(coordinates.lineNum-1)*2]);
    //         if (addLine == 0) {
    //             range.setStart(textNodes[(coordinates.lineNum-1)*2], cursorPosition + lastTextLength);
    //         }else{
    //             range.setStart(textNodes[(coordinates.lineNum-1)*2 + addLine*2], lastTextLength);
    //         }
            
    //         range.collapse(true);

    //         selection.removeAllRanges();
    //         selection.addRange(range);
    //     }
    // });
    document.addEventListener('DOMContentLoaded', (event) => {
        const textarea = document.getElementById('textarea');

        textarea.addEventListener('keydown', function (event) {


            const activeElement = document.activeElement;
            const textinput = event.target;
            if (activeElement === textinput) {
                if (event.key === 'Enter') {
                    if (event.shiftKey) {
                        // Shift+Enter 입력 시 줄바꿈 처리 (기본 동작)
                    } else {
                        event.preventDefault(); // 기본 Enter 동작을 막음
                        const selection = window.getSelection();
                        const range = selection.getRangeAt(0);
                        const cursorPosition = range.endOffset;
                        enterToNewLineblock(textinput, cursorPosition);

                    }
                }
                if (event.key === 'Backspace') {
                    const selection = window.getSelection();
                    const range = selection.getRangeAt(0);
                    const cursorPosition = range.endOffset;
                    const textBeforeCursor = textinput.textContent.substring(0, cursorPosition);
                    if (getCursorCoordinates(textinput).lineNum == 1 && textBeforeCursor === '') {
                        event.preventDefault(); // 기본 Backspace 동작을 막음
                        curLineblock = textinput.parentNode.parentNode.parentNode;
                        deleteLineblock(curLineblock, textinput.textContent);
                    }
                }
                else if (event.key === 'ArrowLeft') {
                    const selection = window.getSelection();
                    const range = selection.getRangeAt(0);
                    if (range.startOffset === 0 && range.endOffset === 0) {
                        const curLineblock = textinput.parentNode.parentNode.parentNode;
                        const previousLineblock = curLineblock.previousElementSibling;
                        const previousTextInput = previousLineblock.children[1].children[0].children[0];
                        if (previousTextInput && previousLineblock.classList.contains('lineblock')) {
                            event.preventDefault();
                            moveCursorToPositionBottom(previousTextInput, 1000);
                        }
                    }
                }
                else if (event.key === 'ArrowRight') {
                    const selection = window.getSelection();
                    const range = selection.getRangeAt(0);
                    console.log("range:",range);
                    const curLineblock = textinput.parentNode.parentNode.parentNode;
                    const textNodes = getTextNodes(textinput);
                    if (range.endContainer === textNodes[textNodes.length-1] && range.endOffset === textNodes[textNodes.length-1].length) {
                        const nextLineblock = curLineblock.nextElementSibling;
                        const nextTextInput = nextLineblock.children[1].children[0].children[0];
                        if (nextTextInput && nextLineblock.classList.contains('lineblock')) {
                            event.preventDefault();
                            moveCursorToPositionTop(nextTextInput, 0);
                        }
                    }
                }
                else if (event.key === 'ArrowDown') {
                    const selection = window.getSelection();
                    const range = selection.getRangeAt(0);
                    const curLineblock = textinput.parentNode.parentNode.parentNode;

                    const nextLineblock = curLineblock.nextElementSibling;
                    const nextTextInput = nextLineblock.children[1].children[0].children[0];
                    if (nextTextInput && nextLineblock.classList.contains('lineblock')) {
                        const coordinates = getCursorCoordinates(textinput);
                        if (coordinates.lineNum === coordinates.lastLine || coordinates.lineNum === NaN) {
                            event.preventDefault();
                            const selection = window.getSelection();
                            const range = selection.getRangeAt(0);
                            const cursorPosition = range.endOffset;
                            moveCursorToPositionTop(nextTextInput, cursorPosition);
                        }

                    }
                }
                else if (event.key === 'ArrowUp') {
                    const selection = window.getSelection();
                    const range = selection.getRangeAt(0);
                    const curLineblock = textinput.parentNode.parentNode.parentNode;
                    const previousLineblock = curLineblock.previousElementSibling;
                    const previousTextInput = previousLineblock.children[1].children[0].children[0];
                    if (previousTextInput && previousLineblock.classList.contains('lineblock')) {
                        const coordinates = getCursorCoordinates(textinput);
                        if (coordinates.lineNum === 1 || coordinates.lineNum === NaN) {
                            event.preventDefault();
                            const selection = window.getSelection();
                            const range = selection.getRangeAt(0);
                            const cursorPosition = range.endOffset;
                            moveCursorToPositionBottom(previousTextInput, cursorPosition);
                        }
                    }
                }
            }
        });
    });
</script>
{% endblock bodyscript %}